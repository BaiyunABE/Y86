### 转换后的Markdown文档  

# Y86流水线处理器 Verilog实现文档  

## 1. 概述  
### 1.1. 设计背景  
本设计基于Y86指令集架构，实现了一个支持基本计算、数据传输和控制流操作的5级流水线处理器。  

### 1.2. 设计目标  
1. 完整实现Y86指令集的核心功能  
2. 采用经典的5级流水线架构（取指、译码、执行、访存、写回）  
3. 支持数据转发（forwarding）等冒险处理机制  
4. 实现条件码（CC）和条件执行功能  
5. 提供基本的异常处理能力  

### 1.3. 文档结构  
后续章节将详细说明：  
1. 指令集架构和编码格式  
2. 流水线各阶段的具体实现  
3. 冒险处理机制  
4. 异常处理机制  
5. 性能分析和优化方向  

---

## 2. 指令集体系结构  
### 2.1. 程序员可见的状态  
Y86处理器中程序员可见的状态如下：  
- **RF**: 程序寄存器  

| %rax | %rsp | %r8  | %r12 |  
|------|------|------|------|  
| %rcx | %rbp | %r9  | %r13 |  
| %rdx | %rsi | %r10 | %r14 |  
| %rbx | %rdi | %r11 |      |  

- **Stat**: 程序状态  
- **CC**: 条件码  
  [](@replace=1)
  
- **DMEM**: 内存  
  [](@replace=2)
  

> **注**：与x86不同，Y86删去了寄存器`%r15`与`CF`。  

### 2.2. Y86指令  
[](@replace=3)
  

**关键差异**：  
- `movq`指令分为四类：`rrmovq`（寄存器→寄存器）、`irmovq`（立即数→寄存器）、`rmmovq`（寄存器→内存）、`mrmovq`（内存→寄存器）。  
- `halt`指令停止执行（等价于x86的`hlt`）。  

### 2.3. 指令编码  
指令编码规则：  
1. 首字节高4位为**代码部分**（标识指令类型），低4位为**功能部分**（细化操作）。  
2. 寄存器标识符分配如下：  

| 寄存器 | ID | 寄存器 | ID |  
|--------|----|--------|----|  
| `%rax` | 0  | `%r8`  | 8  |  
| `%rcx` | 1  | `%r9`  | 9  |  
| `%rdx` | 2  | `%r10` | A  |  
| `%rbx` | 3  | `%r11` | B  |  
| `%rsp` | 4  | `%r12` | C  |  
| `%rbp` | 5  | `%r13` | D  |  
| `%rsi` | 6  | `%r14` | E  |  
| `%rdi` | 7  |        |    |  

### 2.4. Y86异常  
状态码`Stat`描述程序执行状态：  

| 值  | 名称   | 含义           |  
|-----|--------|----------------|  
| 1   | `AOK`  | 正常操作       |  
| 2   | `HLT`  | 遇到`halt`指令 |  
| 3   | `ADR`  | 非法地址       |  
| 4   | `INS`  | 非法指令       |  

---

## 3. 阶段设计  
处理指令分为5个阶段：  
### 3.1. 取指（Fetch）  
- 从内存读取指令（地址=`PC`值）。  
- 提取指令指示符字节：`icode`（高4位）、`ifun`（低4位）。  
- 解析寄存器操作数（`rA`, `rB`）和常数字（`valC`）。  
- 计算下一条指令地址`valP`。  

### 3.2. 译码（Decode）  
- 从寄存器文件读取操作数（`valA`/`valB`）。  

### 3.3. 执行（Execute）  
- ALU执行操作（计算有效地址、栈指针增减等），结果记为`valE`。  
- 更新条件码（`CC`）。  

### 3.4. 访存（Memory）  
- 读写内存，读取的值记为`valM`。  

### 3.5. 写回（Writeback）  
- 写结果到寄存器文件（最多两个结果）。  

---

## 4. 流水线化  
### 4.1. 转发（Forwarding）  
解决**数据冒险**（写操作晚于读操作）：  
```verilog
always @(*) begin
  if (d_srcB == e_dstE)
    d_valB = e_valE;
  else if (d_srcB == M_dstM)
    d_valB = M_valE;
  else if (d_srcB == W_dstM)
    d_valB = W_valM;
  else if (d_srcB == W_dstE)
    d_valB = W_valE;
  else
    d_valB = d_rvalB;
end
```  
> **注**：加载/使用冒险（从内存读取后立即使用）需特殊处理（见4.3）。  

### 4.2. 分支预测  
- 默认预测条件分支**被选择**：  
```verilog
always @(*) begin
  if (f_icode == IJXX || f_icode == ICALL)
    f_predPC = f_valC;  // 预测跳转
  else
    f_predPC = f_valP;  // 预测不跳转
end
```  

### 4.3. 流水线控制逻辑  
处理三种情况：  
| 条件                | 策略（流水线寄存器） |  
|---------------------|----------------------|  
| **处理`ret`**       | 暂停 `F`，气泡 `D`  |  
| **加载/使用冒险**   | 暂停 `F`/`D`，气泡 `E` |  
| **预测错误的分支**  | 气泡 `D`/`E`        |  

特殊逻辑（避免冲突）：  
```verilog
assign D_bubble =
  (E_icode == IJXX && !e_Cnd) ||
  !((E_icode == IMRMOVQ || E_icode == IPOPQ) &&
    (E_dstM == d_srcA || E_dstM == d_srcB)) &&
  (D_icode == IRET || E_icode == IRET || M_icode == IRET);
```  

---

## 5. 性能分析和优化方向  
### 5.1. 性能分析  
CPI计算公式：  
$$
CPI = 1.0 + \frac{C_b}{C_i} = 1.0 + lp + mp + rp
$$  
- $C_i$: 总指令数  
- $C_b$: 总气泡数  

处罚项分解：  
| 原因         | 名称 | 指令频率 | 条件频率 | 气泡数 | 处罚值 |  
|--------------|------|----------|----------|--------|--------|  
| 加载/使用    | lp   | 0.25     | 0.20     | 1      | 0.05   |  
| 预测错误     | mp   | 0.20     | 0.40     | 2      | 0.16   |  
| 返回         | rp   | 0.02     | 1.00     | 3      | 0.06   |  
| **总处罚**   |      |          |          |        | 0.27   |  

> **结论**：CPI = 1.27，优化重点是**预测错误的分支**。  

### 5.2. 合并信号  
减少流水线寄存器状态：  
```verilog
always @(*) begin
  if (D_icode == ICALL || D_icode == IJXX)
    d_valA = D_valP;  // 合并 valP 到 valA
  else
    // 转发逻辑（略）
end
```  

### 5.3. 改进分支预测  
- **当前策略**：总是预测分支（成功率≈60%）。  
- **优化策略**：反向选择/正向不选择（成功率≈65%）。  
  > **原理**：循环由后向分支结束（执行多次），前向分支用于条件操作（执行较少）。  

### 5.4. 使用栈的返回地址预测  
- 硬件维护返回地址栈（调用指令压入，返回指令弹出）。  
- 预测成功率极高（过程调用与返回成对出现）。  

---

## 附录：Y86处理器硬件结构图  
[](@replace=4)